基于网络协议的socket分为TCP socket和UDP socket(面向连接，基于流的socket)

TCP/IP协议栈    四层    应用层  TCP层/UDP层  IP层  链路层

链路层
是物理链接领域标准化的结果，专门定义LAN,WAN,MAN等网络标准

IP层
决定路径的选择
IP本身是不可靠，面向消息的协议，每次传输数据时都会帮我们选择路径，但是不一致，如果传输中发生路径错误，则选择其他路径，如果发生数据丢失或错误，则无法解决

TCP/UDP层
决定主机之间的传输方式
以IP层提供的路径信息为基础完成实际的数据传输，故这层又被称为传输层
IP层只关注单个数据包的传输过程，传输顺序和传输本身不可靠，而TCP会确保数据包传输的顺序和是否传输成功

应用层
编写软件的过程中，需要根据程序特点决定服务器和客户端之间的数据传输规则
网络编程的大部分内容就是设计并实现应用层协议

TCP服务器端的默认函数调用顺序
socket()创建socket

bind()分配socket地址

listen(int sock,int backlog)等待连接请求状态，只有调用了listen函数，客户端才能发出连接请求
sock  希望进入等待连接请求状态的socket文件描述符，传递的描述符socket参数成为服务器端socket
backlog  连接请求等待队列的长度，若为5，则队列长度为5，表示最多使5个连接请求进入队列

accept()允许连接
之前创建的socket是服务器端socket，这是受理连接请求的，但是与客户端的数据交换也需要socket，所以accept内部自动创建一个用于数据I/O的socket，并返回其文件描述符
read()/write()数据交换

close()断开连接



TCP客户端的默认函数调用顺序
socket()

connect(int sock,struct sockaddr * servaddr,socklen_t addrlen);
网络数据交换必须分配IP和端口，但是在代码里没有体现出来，而是在connect里，操作系统内核自动分配本地地址，IP是计算机（主机）的IP，端口随机
sock 客户端socket文件描述符
servaddr  保存目标服务器端地址信息的变量地址值
addrlen  以字节为单位传递已经传递给第二个结构体参数servaddr的地址变量长度

read()/write()

close()

TCP socket中的I/O缓冲

write函数调用后并非立即传输数据，read()函数调用后也并非马上接收数据，
write函数调用瞬间，数据将移至输出缓冲，read函数调用瞬间，从输入缓冲读取数据
write函数不会在向主机的数据传输时返回，而是在数据移到输出缓冲时，TCP 会保证对输出缓冲数据的传输，所以说write函数在数据传输完成时返回
I/O缓冲特性：
在每一个TCP socket中单独存在
在创建socket时自动生成
即使关闭socket也会传递输出缓冲中遗留的数据
关闭socket将丢失输入缓冲的数据

不会发生超过输入缓冲大小的数据传输

TCP内部工作原理
1：与对方socket的连接
三次握手
socket是全双工方式工作，双向传递数据

首先  请求连接的主机A向主机B发送信息
    [SYN] SEQ:1000,ACK:-
    含义如下：现传递的数据包序号为1000，如果接受无误，请通知我向你传递1001号数据包，SYN是首次请求连接时使用的消息，表示收发数据前传输的同步消息
    AKC为空    
接下来主机B向主机A传递消息：
    [SYN+ACK] SEQ:2000,ACK:1001
    含义：现传递的数据包序号为2000，如果接收无误，请通知我向你传输2001号数据包
    ACK 1001的含义：刚才传输的SEQ为1000的数据包接受无误，现在请传递SEQ为1001的数据包
    对主机A首次传输的数据包的确认消息(ACK 1001)和为主机B传输数据做准备的同步消息(SEQ 2000)捆绑发送，因此此种类型的消息又称SYK+ACK

最后主机A向主机B传输的消息：
    [ACK] SEQ:1001,ACK:2001
    该数据包传递如下消息：
    已正确收到传输的SEQ为2000的数据包，现在可以传输SEQ为2001的数据包

2:与对方主机的数据交换

3:断开与socket的连接
四次握手
如果对方还有数据需要传输时直接断开会出现问题，所以要双方协商
先由A向B传递断开连接的消息，B发出确认收到的消息，然后向A传递可以断开连接的消息，A同样发出确认消息